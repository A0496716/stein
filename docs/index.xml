<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stein Documentations</title>
    <link>https://b4b4r07.github.io/stein/</link>
    <description>Recent content on Stein Documentations</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Jan 2019 15:26:15 +0000</lastBuildDate>
    
	<atom:link href="https://b4b4r07.github.io/stein/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Policy</title>
      <link>https://b4b4r07.github.io/stein/concepts/policy/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/concepts/policy/</guid>
      <description>What&amp;rsquo;s a policy? Why needs policies? Nowadays, thanks to the infiltration of the concept of &amp;ldquo;Infrastructure as Code&amp;rdquo;, many infrastructure settings are coded in a configuration file language such as YAML.
For YAML files that we have to maintain like Kubernetes manifest files, as we continue to maintain them in the meantime, we will want to unify the writing style with policies like a style guide.</description>
    </item>
    
    <item>
      <title>Policy as Code</title>
      <link>https://b4b4r07.github.io/stein/concepts/policy-as-code/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/concepts/policy-as-code/</guid>
      <description>Policy as code is the idea of writing code in a high-level language to manage and automate policies. By representing policies as code in text files, proven software development best practices can be adopted such as version control, automated testing, and automated deployment.
Many existing policy or ACL systems do not practice policy as code. Many policies are set by clicking in a GUI, which isn&amp;rsquo;t easily repeatable nor versionable. They usually don&amp;rsquo;t provide any system for testing policies other than testing an action that would violate the policy.</description>
    </item>
    
    <item>
      <title>Rule Configuration</title>
      <link>https://b4b4r07.github.io/stein/configuration/policy/rules/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/policy/rules/</guid>
      <description>The most important thing you&amp;rsquo;ll configure with Stein are rules. Rules are a component of your policies. It might be some rule set such as a region to be deployed, naming convention, or some linting. Or it can be a higher level component such as an email provider, DNS record, or database provider.
This page assumes you&amp;rsquo;re familiar with the [configuration syntax]() already.
Example A rule configuration looks like the following:</description>
    </item>
    
    <item>
      <title>Variable Configuration</title>
      <link>https://b4b4r07.github.io/stein/configuration/policy/variables/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/policy/variables/</guid>
      <description>Input variables serve as parameters for a Terraform module.
When used in the root module of a configuration, variables can be set from CLI arguments and environment variables. For [child modules](), they allow values to pass from parent to child.
Input variable usage is introduced in the Getting Started guide section [Input Variables]().
This page assumes you&amp;rsquo;re familiar with the [configuration syntax]() already.
Example Input variables can be defined as follows:</description>
    </item>
    
    <item>
      <title>Function Configuration</title>
      <link>https://b4b4r07.github.io/stein/configuration/policy/functions/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/policy/functions/</guid>
      <description>It is recommended that you read the Custom Functions page prior to reading this section of the documentation. The page will explain what the custom functions are and how to use them. On the other hands, this documentation will guide you the basics of writing custom functions and introducing it into your policies efficiently.
Example A function configuration looks like the following:
function &amp;#34;get_service_name&amp;#34; { params = [file] result = basename(dirname(dirname(dirname(file)))) } function &amp;#34;get_env&amp;#34; { params = [file] result = basename(dirname(dirname(file))) } function &amp;#34;get_service_id_with_env&amp;#34; { params = [file] result = format(&amp;#34;%s-%s&amp;#34;, get_service_name(file), lookup(var.</description>
    </item>
    
    <item>
      <title>Config Configuration</title>
      <link>https://b4b4r07.github.io/stein/configuration/policy/config/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/policy/config/</guid>
      <description>The config is a block that can describe settings related to stein lint. Basically stein configuration is based on &amp;ldquo;Smart default&amp;rdquo; concept. It means that it has been set up sufficiently from the beginning. Moreover, this means that you can use it without having to define this block and no need to change the setting. However, depending on the item, you may want to customize it. Therefore, you can change the setting according to the config block accordingly.</description>
    </item>
    
    <item>
      <title>Load Order</title>
      <link>https://b4b4r07.github.io/stein/configuration/load/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/load/</guid>
      <description>How policies are loaded by Stein To understand how stein loads policy files and recognizes them is very important for writing and applying policies to the files effectively. stein apply requires always one or more arguments only. It assumes the config file paths such as YAML, JSON and so on.
The path may have a hierarchical structure. In Stein, when a path with a hierarchical structure is given as arguments, stein recognizes the HCL file in .</description>
    </item>
    
    <item>
      <title>Installing Stein</title>
      <link>https://b4b4r07.github.io/stein/intro/install/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/intro/install/</guid>
      <description>Installing Stein is simple. There are two approaches to installing Stein:
 Using a precompiled binary Installing from source  Downloading a precompiled binary is easiest, and we provide downloads over TLS along with SHA256 sums to verify the binary. We also distribute a PGP signature with the SHA256 sums that can be verified.
Precompiled Binaries To install the precompiled binary, download the appropriate package for your system. Stein is currently packaged as a zip file.</description>
    </item>
    
    <item>
      <title>Interpolation Syntax</title>
      <link>https://b4b4r07.github.io/stein/configuration/syntax/interpolation/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/syntax/interpolation/</guid>
      <description>Embedded within strings in Terraform, whether you&amp;rsquo;re using the Terraform syntax or JSON syntax, you can interpolate other values. These interpolations are wrapped in ${}, such as ${var.foo}.
The interpolation syntax is powerful and allows you to reference variables, attributes of resources, call functions, etc.
You can perform simple math in interpolations, allowing you to write conditions such as ${count.index + 1}. And you can also use conditionals to determine a value based on some logic.</description>
    </item>
    
    <item>
      <title>Custom Functions</title>
      <link>https://b4b4r07.github.io/stein/configuration/syntax/custom-functions/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/configuration/syntax/custom-functions/</guid>
      <description>Notes: This idea basically comes from https://github.com/hashicorp/hcl2/tree/master/ext/userfunc
What&amp;rsquo;s custom functions? The custom function feature is like an user-defined functions. You can freely define functions that Stein doesn&amp;rsquo;t provide as a built-in function.
Of course you can define it freely, so you can customize it by wrapping a built-in function, or you can use it like an alias.
Why need custom functions? Stein functions as a versatile testing framework for configuration files such as YAML.</description>
    </item>
    
    <item>
      <title>Writing Stein rules</title>
      <link>https://b4b4r07.github.io/stein/intro/rules/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/intro/rules/</guid>
      <description>Let&amp;rsquo;s say you want to create a lint policy for the next YAML file.
apiVersion:v1metadata:name:my-service# namespace: echospec:selector:app:MyAppports:-protocol:TCPport:80targetPort:9376 This is Kubernetes YAML of Service manifest. The field metadata.namespace in Service can be omitted. However, let&amp;rsquo;s say you want to define it explicitly and force the owner to specify this. In such a case, Stein&amp;rsquo;s Rule is useful. A rule is simple block which can be represented by simple DSL schema by using HCL.</description>
    </item>
    
    <item>
      <title>Running Stein</title>
      <link>https://b4b4r07.github.io/stein/intro/run/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/intro/run/</guid>
      <description>Apply stein rules After writing up your rules, let&amp;rsquo;s run stein command.
The Stein CLI is a well-behaved command line application. In erroneous cases, a non-zero exit status will be returned. It also responds to -h and --help as you&amp;rsquo;d expect. To view a list of the available commands at any time, just run stein with no arguments.
To apply the rule to that YAML file and run the test you can do with the apply subcommand.</description>
    </item>
    
    <item>
      <title>Command: apply</title>
      <link>https://b4b4r07.github.io/stein/commands/apply/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/commands/apply/</guid>
      <description>The stein apply command is used to execute a policy locally for development purposes.
Usage: stein apply [options] POLICY  This command executes the policy file at the path specified by POLICY.
The output will indicate whether the policy passed or failed. The exit code also reflects the status of the policy: 0 is pass, 1 is fail, 2 is undefined (fail, but because the result was undefined), and 2 is a runtime error.</description>
    </item>
    
    <item>
      <title>Command: fmt</title>
      <link>https://b4b4r07.github.io/stein/commands/fmt/</link>
      <pubDate>Thu, 17 Jan 2019 15:26:15 +0000</pubDate>
      
      <guid>https://b4b4r07.github.io/stein/commands/fmt/</guid>
      <description>The stein fmt command formats a policy source to a canonical format.
Usage: stein fmt [options] FILE ...  This command formats all the specified policy files to a canonical format.
By default, policy files are overwritten in place. This behavior can be changed with the -write flag. If a specified FILE is - then stdin is read and the output is always written to stdout.
The command-line flags are all optional.</description>
    </item>
    
  </channel>
</rss>